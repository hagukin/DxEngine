이번 시간에는 에러 발생 시 이를 제대로 처리해줄 수 있도록 C++ exception을 활용하여 기능을 추가할 것이다.  
![image](https://user-images.githubusercontent.com/63915665/224485635-8fc3e5c6-f047-49c1-8cd2-695bf18df790.png)  
커스텀 Exception 클래스를 정의하자.  
![image](https://user-images.githubusercontent.com/63915665/224486227-8d6466ad-626e-4293-8697-9a695ab56b4d.png)  
여기서의 핵심이 되는 내용은 whatBuffer와 what()인데, stringstream을 활용해 타입과 로그 string을 whatBuffer에 저장하고 whatBuffer.c_str()으로 char\*를 반환한다.  
이때 그냥 한번에 return oss.str().c_str()을 하지 않는 이유는 stream의 특성 상 함수 종료시 삭제되기 때문에 (정확히는 stream은 copy가 불가능하므로 함수의 반환값으로 lvalue stream을 사용할 수 없는 것) 함수 외부의 클래스 멤버로 저장된 whatBuffer에 데이터를 저장해둔 후 이를 반환하는 것이다.  
사실 엄청나게 중요한 내용은 아니고, 그냥 stream의 특성을 인지하는 정도면 된다.  

![image](https://user-images.githubusercontent.com/63915665/224486385-dd4330c7-b7dd-482d-9076-3c91f3f23aa2.png)  
이렇게 만든 exception 클래스를 윈도우 프레임워크 클래스 내부로 가져와 winapi 연관 exception은 별도로 정의하자.  
윈도우 exception들의 에로코드들(HRESULT)에 대한 정보가 추가되었음을 알 수 있다.  
![image](https://user-images.githubusercontent.com/63915665/224486466-47cb2e4a-264f-4847-82a4-cded8dcaa8b2.png)  
이 에러코드를 활용해 winapi의 FormatMessage를 이용해 해당 에러코드에 대응되는 에러 string을 반환하도록 다음과 같은 형태로 작성해준다. FormatMessage에 대한 약간의 이해가 있어야 코드 이해가 원활하다. 레퍼런스를 참조하자.  

![image](https://user-images.githubusercontent.com/63915665/224486620-74d7d7c1-7953-41ca-ab02-1124bd96c8eb.png)  
간단한 매크로 형태로 작성함으로 편의를 위해 hr만 전달해줘도 사용가능하게 만든다. (winapi의 LINE, FILE을 일일히 입력해야되는 수고를 덜 수 있다.)  
이렇게 window exception을 정의했으니, 이를 실제로 catch()해주어야 한다.  
```c++
#include "Window.h"


int CALLBACK WinMain(
	HINSTANCE hInstance,
	HINSTANCE hPrevInstance,
	LPSTR     lpCmdLine,
	int       nCmdShow )
{
	try
	{
		Window wnd( 800,300,"Donkey Fart Box" );

		MSG msg;
		BOOL gResult;
		while( (gResult = GetMessage( &msg,nullptr,0,0 )) > 0 )
		{
			// TranslateMessage will post auxilliary WM_CHAR messages from key msgs
			TranslateMessage( &msg );
			DispatchMessage( &msg );
		}

		// check if GetMessage call itself borked
		if( gResult == -1 )
		{
			throw CHWND_LAST_EXCEPT();
		}

		// wParam here is the value passed to PostQuitMessage
		return msg.wParam;
	}
	catch( const ChiliException& e )
	{
		MessageBox( nullptr,e.what(),e.GetType(),MB_OK | MB_ICONEXCLAMATION );
	}
	catch( const std::exception& e )
	{
		MessageBox( nullptr,e.what(),"Standard Exception",MB_OK | MB_ICONEXCLAMATION );
	}
	catch( ... )
	{
		MessageBox( nullptr,"No details available","Unknown Exception",MB_OK | MB_ICONEXCLAMATION );
	}
	return -1;
}
```
에러 발생 시 윈도우 창를 띄우도록 만들었다.  

```c++
throw CHWND_EXCEPT( 에러코드 ); // winapi 에러 유발
throw std::runtime_error("에러 메세지"); // 런타임 에러 유발
throw 123456789; // unknown (define되지 않은) 에러 유발
```
![image](https://user-images.githubusercontent.com/63915665/224486973-9bb897bf-6929-4d7c-a4ad-d0de23bfc5f2.png)  
잘 작동한다!  






